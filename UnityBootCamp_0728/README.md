# 🎮 Unity Life Cycle 핵심 요약

---

## 🚀 유니티 실행 흐름 요약
유니티는 실행부터 종료까지 여러 생명주기 함수들을 통해 게임 오브젝트를 제어함  
→ **초기화 / 활성화 / 프레임당 호출 / 종료 처리**

---

## 🔂 한 번만 실행되는 함수

### 1. `Awake()`
- 씬 실행 시 **무조건 한 번** 호출됨
- 게임 오브젝트가 활성화 상태면, 스크립트 활성화 여부와 무관하게 호출됨
- 다른 컴포넌트 참조 및 초기화에 **안정적인 위치**
- ❗비활성화된 오브젝트는 참조 불가

### 2. `OnEnable()`
- 오브젝트나 스크립트가 **활성화**될 때 호출됨
- 이벤트 연결 등에 사용
- ✅ 상태 재설정 시 유용 (ex: 게임 중 오브젝트 On/Off)

### 3. `Start()`
- `Awake()` 호출 후 실행됨
- 게임 로직 기반 초기화 진행
- 코루틴 사용 가능 (`StartCoroutine()`)

| 함수명      | 코루틴 사용 | 주요 용도                       |
|-------------|--------------|----------------------------------|
| `Awake()`    | ❌           | 변수 초기화, 오브젝트 참조      |
| `OnEnable()` | ❌           | 이벤트 연결 등                  |
| `Start()`    | ✅           | 초기화 기반 게임 로직, 코루틴 처리 |

---

## 🔁 여러 번 반복 호출되는 함수

### 1. `Update()`
- 매 프레임마다 호출 (약 60fps 기준)
- 실시간 입력, 움직임 등 **주요 로직 처리**
- `Time.deltaTime` 등 보정 값 사용
- 과도한 로직은 성능 저하 유발 가능 → 최적화 필수

### 2. `FixedUpdate()`
- 일정한 간격(`Fixed TimeStep`)으로 호출
- **물리 연산** 관련 로직 처리에 적합 (`Rigidbody` 등)
- `TimeScale = 0`이면 호출 멈춤

### 3. `LateUpdate()`
- 모든 `Update`, `FixedUpdate` 종료 후 호출
- **후처리** 작업에 사용 (카메라 따라가기 등)
- 여러 개 존재 시 **스크립트 호출순서**  조정 필요
  

---

## 🎯 Update 최적화 팁
- 무조건 `Update()`에 작성하기보다  
  → `이벤트`, `코루틴`, `Manager` 클래스 등을 적극 활용해 로직 위임  
- 불필요한 반복 호출 피하면 성능 향상됨
---
## 🔁 Unity 생명주기 함수 요약

| 함수명         | 호출 시점                         | 특징                                               |
|----------------|-----------------------------------|----------------------------------------------------|
| `Awake()`       | 오브젝트 활성화 시 **한 번만** 호출 | 초기 참조 안전, 비활성 오브젝트는 참조 불가         |
| `OnEnable()`    | 활성화될 때 호출됨                | 이벤트 연결 위치로 자주 사용됨                     |
| `Start()`       | `Awake()` 후 호출                  | 초기화 및 코루틴 시작 위치                         |
| `Update()`      | 매 프레임마다 호출                 | 키 입력, 이동 등 실시간 로직 처리                  |
| `FixedUpdate()` | 일정 간격 호출 (`FixedTimeStep`)   | 물리 엔진 관련 처리에 적합 (`Rigidbody`)            |
| `LateUpdate()`  | 모든 Update 이후 호출              | 후처리용 → 카메라 위치 조정 등에 사용됨           |


# 🎮 Unity 이론 정리 (Vector, 메모리 구조)

유니티에서 자주 사용하는 Vector와 메모리 구조, 생명주기 함수에 대한 개념 정리입니다.  

---

## 📌 1. 벡터(Vector)의 요소
- `x`: x축 값  
- `y`: y축 값  
- `z`: z축 값  
- `w`: 셰이더나 수학 연산에서 사용되는 Vector4의 네 번째 축

---
## 📌 2. 벡터(Vector)의 특징

- ✅ 구조체(struct) 기반의 **값 타입**  
  → 참조가 아닌 **값 그 자체**를 의미하며, 계산이 빠르게 처리됨
- ✅ 값 복사 시 **값 자체만 복사**  
  → 참조 주소를 따라가지 않음
- ✅ 다양한 벡터 계산 기능 제공  
  → `magnitude`, `normalized`, `Dot`, `Cross` 등 내장 함수 활용 가능
- ✅ 메모리 위치: **스택(Stack)**  
  → 빠른 접근과 자동 해제 구조

---

## 🔄 2-1. 값(Value) vs 참조(Reference)

| 항목           | 값 타입 (Value Type)               | 참조 타입 (Reference Type)            |
|----------------|-------------------------------------|----------------------------------------|
| 저장 방식      | 변수에 값 자체 저장                 | 변수에 객체의 메모리 주소 저장         |
| 메모리 위치    | 스택(Stack)                         | 힙(Heap)                               |
| 예시           | `int num = 5;`                      | `Player p = new Player();`             |
| `new` 사용 목적 | 초기화 용도로 사용됨               | 인스턴스 생성 용도로 사용됨            |
| 복사 방식      | 값 자체 복사됨                      | 참조 주소만 복사됨                     |

---

## ✳️ 2-2. Vector3 초기화 vs 클래스 생성 비교

| 비교 항목         | `Vector3` 구조체 초기화           | 클래스 인스턴스 생성               |
|------------------|-----------------------------------|------------------------------------|
| 목적             | 좌표값(x, y, z) 초기화             | 기능 및 상태를 가진 객체 생성       |
| 메모리 위치      | 스택                              | 힙                                |
| `new` 의미        | 값만 세팅                          | 새로운 객체 생성                   |
| 예시 코드        | `Vector3 pos = new Vector3(0,1,0);` | `Player player = new Player();`   |

---
## 💡 메모리 저장 영역

프로그램이 실행되기 위해서는 운영체제(OS)가 프로그램 정보를 메모리에 로드해야 합니다. 실행 중에는 중앙 제어 장치(CPU)가 코드를 처리하기 위해 명령어와 데이터를 메모리에 저장하고 접근합니다.

컴퓨터 메모리는 바이트(Byte) 단위로 번호가 붙은 선형적인 공간입니다.  
이 공간은 낮은 주소부터 높은 주소까지 정렬되어 있으며, 각 저장 영역이 고유한 역할을 갖습니다:

---

## 🧮 가벼운 데이터 vs 무거운 데이터 비교

| 항목             | 🧊 가벼운 데이터                       | 🔥 무거운 데이터                              |
|------------------|----------------------------------------|------------------------------------------------|
| 메모리 위치       | 스택(Stack)                            | 힙(Heap), 외부 리소스                           |
| 예시             | `int`, `float`, `Vector3`, `bool`      | 클래스 인스턴스, 텍스처, 오디오, 애니메이션 등 |
| 할당 방식         | 자동 할당 / 빠름                        | 명시적 생성 (`new`) / GC 관리 / 느림           |
| 용량             | 작음                                    | 큼 (수 KB ~ MB 이상도 가능)                    |
| 관리 방식         | 함수 종료 시 자동 해제                  | 직접 또는 GC에 의해 해제                       |

---

---

## 💾 대표적인 메모리 공간

### ✅ 코드(Code)
- 실행할 프로그램 코드가 저장되는 영역 (텍스트 영역)
- CPU는 이 영역에서 명령어를 하나씩 읽어와 실행함
- 프로그램 시작부터 종료까지 지속적으로 존재하는 불변 영역

### ✅ 데이터(Data)
- 전역 변수와 정적(static) 변수들이 저장되는 영역
- **전역 변수**: 전체 코드에서 접근 가능한 변수 (C#에서는 클래스 수준의 정적 변수로 대체)
- **정적 변수**: 클래스명.변수명으로 객체 없이 접근 가능
- 프로그램 시작 시 메모리에 할당되며 종료될 때까지 유지

### ✅ 힙(Heap)
- 참조 타입의 객체가 저장되는 영역
- C/C++에선 직접 할당/해제하며, C#에서는 GC(Garbage Collector)에 의해 자동 관리됨
- 저장 순서나 정렬은 중요하지 않으며, 메모리 접근 속도는 상대적으로 느림
- 할당된 메모리가 크고 GC 활동이 많아지면 성능 저하 발생 가능

### ✅ 스택(Stack)
- 함수 호출 시 자동으로 사용되는 임시 메모리 공간
- 지역 변수 및 매개변수가 저장되며 함수 종료 시 자동 해제됨
- 매우 빠른 처리 속도를 자랑하며, **스택 프레임(Stack Frame)** 단위로 작동
- 데이터는 LIFO(Last In First Out) 방식으로 관리됨

---

📌 **요약 구조**

| 메모리 영역 | 주요 역할                           | 관리 방식                         | 접근 속도   |
|-------------|--------------------------------------|------------------------------------|-------------|
| 코드        | 실행 명령어 저장                      | 프로그램 전반에서 지속 유지         | 매우 빠름    |
| 데이터      | 정적/전역 변수 저장                   | 자동 할당 및 유지                   | 빠름         |
| 힙          | 참조 타입 객체 저장                   | 직접 또는 GC에 의한 자동 관리       | 느림         |
| 스택        | 지역 변수 및 매개변수 저장             | 자동 생성 및 자동 해제              | 매우 빠름    |

---

## 🧠 기타 개념 보강

### ✔️ 구조체 vs 클래스

| 항목         |                | 참구조체 (struct)         | 클래스 (class)             |
|--------------|--------------------------|-----------------------------|
| 타입         | 값 타입   조 타입                  |
| 상속         | ❌ 불가능                 | ✅ 가능                    |
| 생성 방식    | 자동 할당                | `new` 키워드 필요           |
| 메모리 위치  | 스택                     | 힙                         |

### ✔️ GC(Garbage Collector)
- 사용하지 않는 객체를 자동 회수  
- 성능 최적화를 위해 메모리 관리 중요  
- 과도한 객체 생성 → GC 비용 증가 → 성능 저하

### ✔️ Null 처리
- `null` 참조 방지를 위한 체크 필수  
- Unity에서는 `gameObject == null` 확인 습관화

---

✅ **복습용 요약 정리**  
- Vector3는 구조체이므로 값 타입이며 빠르고 단순함  
- 클래스는 동작과 상태를 함께 담아야 할 때 사용  
- Unity 생명주기 함수는 호출 순서와 사용 목적을 정확히 알아야 성능 최적화 가능



