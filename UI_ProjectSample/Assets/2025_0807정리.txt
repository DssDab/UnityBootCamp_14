1. SceneManager.LoadScene("씬 이름")
해당 기능을 호출하면 다음 씬으로 이동.


2. Canvas : UI 작업을 위해 반드시 필요한 오브젝트, UI에서 다루는 값(버튼, 이미지)등은
캔버스의 자식으로써 사용.

3. 입력 모듈(키보드, 마우스)로 인한 입력 
   전달
	 --> 이벤트 확인
	 --> 기능 수행

4. #if UNITY_EDITOR
EditorApplication.Exit(0); : 유니티 에디터 종료
// 유니티 에디터 종료
EditorApplication.isPlaying = false;
// 유니티 에디터의 게임 모드에 대한 종료
#endif
=======================================================
텍스트 타이핑  효과를 이용해서
간단한 대화 프로그램 만들기

Canvas 생성(DialogUI)
-Panel : Rect가 stretch로 설정되어있고,
	Color의 알파 값이 투명하게 설정되어있는 이미지
- Name
- Message

레이아웃 배치
(레이아웃 기능을 붙이면 자식 오브젝트에 대한
배치를 간단히 진행할 수 있습니다.)
배치가 끝나면 해당 기능을 제거.

-Panel
컴포넌트 Vertical Layout Group 연결

Vertical (세로),  Horizontal(가로), Grid(격자)

Chile Alignment : 자식에 대한 정렬 위치
Padding을 통해 오브젝트 배치 위치 설정
Spacing을 통해 다음 값과의 간격 설정

런타임에서 Layout의 요소가 변경되지 않는
경우라면 Group은 정렬용으로만
사용하고 이후 제거하는 방식을 선택해줌.
=======================================================
DialogManager.cs 생성
using TMPro;

필드(public에 대한 값 들만)
- 텍스트(TMP) 대화 텍스트
- 텍스트(TMP) 대화 캐릭터 이름
- 패널(GameObject) 

필드(private에 대한 값 들만)
- Queue<T> : 대화 내용 큐로 구현
- Coroutine : 타이핑에 대한 코루틴
 - bool : 타이핑 진행 여부 체크
 - Dialog : 대화 내용(큐에 등록)

※ [Serializable] ※ (직렬화)
-	       

	※ 생성자 ※
// 클래스 생성 시 호출되는 메소드(생성자)

	※ this ※
// this는 클래스 자신을 의미합니다.
// 클래스가 가진 값과 매개변수의 이름이 같아서 구분하기 위한 용도

※ TextMeshProUGUI TextMeshProUGUI ※
-
=======================================================
	Collection 문법

	※ 큐(Queue) ※ 
	   -자료구조-
-선입 선출 구조로 설계되어있는 자료구조 (First-In-First-Out) FIFO
--> 먼저 넣어준 데이터가 먼저 제거되는 방식
(대화, 대기열 등의 기능을 구현할 때 우선적으로 
고려되는 자료구조)

특징)
Enqueue(값) : 데이터 추가

Dequeue() : 가장 먼저 들어온 값 제거

Peek() : 현재 가장 먼저 들어와있는 값 확인 가능

Count() : 현재 큐에 등록된 요소의 개수

ex)
Queue<string> message = new Queue<string>(); // 큐 생성
message.Enqueue("오늘의 추천 메뉴는.");
message.Enqueue("바나나맛 우유입니다.");

string data = message.Dequeue();
// 첫번째 대사인 오늘의 추천 메뉴는... "이 return 되고,
 큐 내부에서 삭제됩니다.

	※StringBuilder※
System.Text.StringBuilder 클래스는
문자열을 효율적으로 다룰 수 있게 도와주는 클래스입니다.

사용 목적
C#의 string은 한번 생성되면 수정이 불가능합니다.
(immutable object) 불변 객체

문자열의 경우 + 연산이 진행되면 새로운 문자열을
생성하는 구조 
(GC에 의해 재할당 하기 전에 데이터가 임의로 삭제되기 때문에 그만큼 코스트가 발생함)

StringBuilder의 경우는 내부에 있는 버퍼에 의해
문자열을 누적해서 수정할 수 있습니다.

StringBuilder의 기능
1. Append() : 문자열 결합
2. AppendLine() : 문자열 + 줄바꿈
3. Insert() : 원하는 위치에 문자열 삽입
4. Remove() : 인덱스 기준으로 문자열 삭제하기
5. Replace() : 특정 문자를 다른 값으로 교체하기
6. Clear() : 문자열 전체 제거
7. ToString() : 결과물로 변환

성능에 대한 비교
string에서의 + 연산 과정 vs StringBuilder
작업량 많을 경우 Builder가 유리
작업량이 적을 경우 string + 가 유리
GC 발생 여부 Builder가 더 적게 발생합니다.
실시간 조작 여부 : Builder가 최적화 단계에서 더 유리합니다.

=======================================================
